<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>VICTUS-1 // Contested Autonomy</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// VICTUS-1 // CONTESTED AUTONOMY
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Audio context
let audioCtx = null;
let musicGain = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        musicGain = audioCtx.createGain();
        musicGain.gain.value = 0.3;
        musicGain.connect(audioCtx.destination);
    }
}

// ============ SOUND EFFECTS ============
function playExplosion() {
    if (!audioCtx) return;
    // Very soft, muffled thud - barely audible
    const bufferSize = audioCtx.sampleRate * 0.08;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
        const t = i / audioCtx.sampleRate;
        const env = Math.pow(1 - i / bufferSize, 4);
        const thump = Math.sin(2 * Math.PI * 22 * t);
        data[i] = thump * env * 0.2;
    }

    const source = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    source.buffer = buffer;
    gain.gain.value = 0.05;
    source.connect(gain);
    gain.connect(audioCtx.destination);
    source.start();
}

function playBomb() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.8);

    osc2.type = 'square';
    osc2.frequency.setValueAtTime(80, audioCtx.currentTime);
    osc2.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.8);

    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);

    osc.connect(gain);
    osc2.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc2.start();
    osc.stop(audioCtx.currentTime + 0.8);
    osc2.stop(audioCtx.currentTime + 0.8);
}

function playBossHit() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(180, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.12);
    gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.12);
}

function playBossShoot() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(250, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
}

function playWarning() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = 440;
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.setValueAtTime(0, audioCtx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime + 0.2);
    gain.gain.setValueAtTime(0, audioCtx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.3);
}

// ============ MUSIC SYSTEM - NINE INCH NAILS INDUSTRIAL 8-BIT ============
let musicPlaying = false;
let musicNodes = [];

function makeDistortionCurve(amount) {
    const samples = 44100;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

function startMusic() {
    if (musicPlaying || !audioCtx) return;
    musicPlaying = true;

    const bpm = 140;
    const beatTime = 60 / bpm;
    const now = audioCtx.currentTime;
    const loopDuration = 32 * beatTime;

    const bassSequence = [
        41.20, 41.20, 41.20, 41.20,
        38.89, 38.89, 38.89, 38.89,
        36.71, 36.71, 36.71, 36.71,
        41.20, 43.65, 41.20, 38.89,
    ];

    function scheduleLoop(startTime) {
        if (!musicPlaying) return;

        for (let beat = 0; beat < 32; beat++) {
            const kickTime = startTime + beat * beatTime;

            const kickSub = audioCtx.createOscillator();
            const kickSubGain = audioCtx.createGain();
            kickSub.type = 'sine';
            kickSub.frequency.setValueAtTime(80, kickTime);
            kickSub.frequency.exponentialRampToValueAtTime(30, kickTime + 0.12);
            kickSubGain.gain.setValueAtTime(0.5, kickTime);
            kickSubGain.gain.exponentialRampToValueAtTime(0.001, kickTime + 0.2);
            kickSub.connect(kickSubGain);
            kickSubGain.connect(musicGain);
            kickSub.start(kickTime);
            kickSub.stop(kickTime + 0.25);
            musicNodes.push({osc: kickSub});

            const clickBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.03, audioCtx.sampleRate);
            const clickData = clickBuffer.getChannelData(0);
            for (let j = 0; j < clickBuffer.length; j++) {
                const t = j / audioCtx.sampleRate;
                const env = Math.pow(1 - j / clickBuffer.length, 8);
                clickData[j] = Math.sin(t * 4000) * env * 0.5 + (Math.random() - 0.5) * env * 0.3;
            }
            const clickSource = audioCtx.createBufferSource();
            const clickGain = audioCtx.createGain();
            clickSource.buffer = clickBuffer;
            clickGain.gain.value = 0.12;
            clickSource.connect(clickGain);
            clickGain.connect(musicGain);
            clickSource.start(kickTime);
            musicNodes.push({source: clickSource});

            if (beat % 2 === 1) {
                const ghostKick = audioCtx.createOscillator();
                const ghostGain = audioCtx.createGain();
                ghostKick.type = 'triangle';
                ghostKick.frequency.setValueAtTime(60, kickTime + beatTime * 0.5);
                ghostKick.frequency.exponentialRampToValueAtTime(25, kickTime + beatTime * 0.5 + 0.08);
                ghostGain.gain.setValueAtTime(0.2, kickTime + beatTime * 0.5);
                ghostGain.gain.exponentialRampToValueAtTime(0.001, kickTime + beatTime * 0.5 + 0.1);
                ghostKick.connect(ghostGain);
                ghostGain.connect(musicGain);
                ghostKick.start(kickTime + beatTime * 0.5);
                ghostKick.stop(kickTime + beatTime * 0.5 + 0.15);
                musicNodes.push({osc: ghostKick});
            }
        }

        for (let beat = 0; beat < 32; beat++) {
            if (beat % 2 === 1) {
                const snareTime = startTime + beat * beatTime;
                const snareBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
                const snareData = snareBuffer.getChannelData(0);
                for (let j = 0; j < snareBuffer.length; j++) {
                    const t = j / audioCtx.sampleRate;
                    const env = Math.pow(1 - j / snareBuffer.length, 2);
                    const tone = Math.sin(t * 180 * Math.PI * 2) * 0.4;
                    const noise = (Math.random() * 2 - 1) * 0.6;
                    snareData[j] = (tone + noise) * env;
                }
                const snareSource = audioCtx.createBufferSource();
                const snareGain = audioCtx.createGain();
                snareSource.buffer = snareBuffer;
                snareGain.gain.value = 0.15;
                snareSource.connect(snareGain);
                snareGain.connect(musicGain);
                snareSource.start(snareTime);
                musicNodes.push({source: snareSource});
            }
        }

        for (let i = 0; i < 64; i++) {
            const hhTime = startTime + i * beatTime * 0.5;
            const isAccent = i % 4 === 0;
            const hhBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.04, audioCtx.sampleRate);
            const hhData = hhBuffer.getChannelData(0);
            for (let j = 0; j < hhBuffer.length; j++) {
                const env = Math.pow(1 - j / hhBuffer.length, isAccent ? 3 : 6);
                hhData[j] = (Math.random() * 2 - 1) * env;
            }
            const hhSource = audioCtx.createBufferSource();
            const hhGain = audioCtx.createGain();
            hhSource.buffer = hhBuffer;
            hhGain.gain.value = isAccent ? 0.07 : 0.03;
            hhSource.connect(hhGain);
            hhGain.connect(musicGain);
            hhSource.start(hhTime);
            musicNodes.push({source: hhSource});
        }

        for (let i = 0; i < 16; i++) {
            const bassTime = startTime + i * 2 * beatTime;
            const bassNote = bassSequence[i % 16];

            const bassOsc = audioCtx.createOscillator();
            const bassOsc2 = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            const distortion = audioCtx.createWaveShaper();

            bassOsc.type = 'sawtooth';
            bassOsc.frequency.value = bassNote;
            bassOsc2.type = 'square';
            bassOsc2.frequency.value = bassNote * 1.01;

            distortion.curve = makeDistortionCurve(20);
            distortion.oversample = '2x';

            bassGain.gain.setValueAtTime(0, bassTime);
            bassGain.gain.linearRampToValueAtTime(0.1, bassTime + 0.02);
            bassGain.gain.setValueAtTime(0.08, bassTime + beatTime * 1.5);
            bassGain.gain.linearRampToValueAtTime(0, bassTime + beatTime * 1.9);

            bassOsc.connect(distortion);
            bassOsc2.connect(distortion);
            distortion.connect(bassGain);
            bassGain.connect(musicGain);
            bassOsc.start(bassTime);
            bassOsc2.start(bassTime);
            bassOsc.stop(bassTime + beatTime * 2);
            bassOsc2.stop(bassTime + beatTime * 2);
            musicNodes.push({osc: bassOsc});

            const subOsc = audioCtx.createOscillator();
            const subGain = audioCtx.createGain();
            subOsc.type = 'sine';
            subOsc.frequency.value = bassNote;
            subGain.gain.setValueAtTime(0, bassTime);
            subGain.gain.linearRampToValueAtTime(0.15, bassTime + 0.03);
            subGain.gain.linearRampToValueAtTime(0.1, bassTime + beatTime);
            subGain.gain.linearRampToValueAtTime(0, bassTime + beatTime * 1.9);
            subOsc.connect(subGain);
            subGain.connect(musicGain);
            subOsc.start(bassTime);
            subOsc.stop(bassTime + beatTime * 2);
            musicNodes.push({osc: subOsc});
        }

        const stabPattern = [0, 4, 8, 12, 16, 20, 24, 28];
        const stabNotes = [164.81, 155.56, 146.83, 164.81];

        stabPattern.forEach((beat, idx) => {
            const stabTime = startTime + beat * beatTime;
            const note = stabNotes[idx % stabNotes.length];

            const stabOsc = audioCtx.createOscillator();
            const stabOsc2 = audioCtx.createOscillator();
            const stabGain = audioCtx.createGain();

            stabOsc.type = 'square';
            stabOsc.frequency.value = note;
            stabOsc2.type = 'square';
            stabOsc2.frequency.value = note * 2.01;

            stabGain.gain.setValueAtTime(0, stabTime);
            stabGain.gain.linearRampToValueAtTime(0.06, stabTime + 0.01);
            stabGain.gain.setValueAtTime(0.04, stabTime + beatTime * 0.5);
            stabGain.gain.exponentialRampToValueAtTime(0.001, stabTime + beatTime * 1.5);

            stabOsc.connect(stabGain);
            stabOsc2.connect(stabGain);
            stabGain.connect(musicGain);
            stabOsc.start(stabTime);
            stabOsc2.start(stabTime);
            stabOsc.stop(stabTime + beatTime * 2);
            stabOsc2.stop(stabTime + beatTime * 2);
            musicNodes.push({osc: stabOsc});
        });

        const droneOsc1 = audioCtx.createOscillator();
        const droneOsc2 = audioCtx.createOscillator();
        const droneOsc3 = audioCtx.createOscillator();
        const droneGain = audioCtx.createGain();

        droneOsc1.type = 'sawtooth';
        droneOsc1.frequency.value = 82.41;
        droneOsc2.type = 'sawtooth';
        droneOsc2.frequency.value = 82.41 * 1.003;
        droneOsc3.type = 'sawtooth';
        droneOsc3.frequency.value = 82.41 * 0.997;

        droneGain.gain.setValueAtTime(0, startTime);
        droneGain.gain.linearRampToValueAtTime(0.03, startTime + 4);
        droneGain.gain.setValueAtTime(0.03, startTime + loopDuration - 4);
        droneGain.gain.linearRampToValueAtTime(0, startTime + loopDuration);

        droneOsc1.connect(droneGain);
        droneOsc2.connect(droneGain);
        droneOsc3.connect(droneGain);
        droneGain.connect(musicGain);

        droneOsc1.start(startTime);
        droneOsc2.start(startTime);
        droneOsc3.start(startTime);
        droneOsc1.stop(startTime + loopDuration);
        droneOsc2.stop(startTime + loopDuration);
        droneOsc3.stop(startTime + loopDuration);
        musicNodes.push({osc: droneOsc1});

        setTimeout(() => scheduleLoop(startTime + loopDuration), (loopDuration - 1) * 1000);
    }

    scheduleLoop(now);
}

function stopMusic() {
    musicPlaying = false;
    musicNodes.forEach(n => {
        try {
            if (n.osc) n.osc.stop();
            if (n.source) n.source.stop();
        } catch(e) {}
    });
    musicNodes = [];
}

// ============ BOSS MUSIC ============
let bossMusic = false;

function startBossMusic() {
    if (bossMusic || !audioCtx) return;
    stopMusic();
    bossMusic = true;

    const bpm = 160;
    const beatTime = 60 / bpm;
    const now = audioCtx.currentTime;

    const bossNotes = [
        41.20, 38.89, 36.71, 34.65,
        41.20, 38.89, 36.71, 32.70,
    ];

    const loopDuration = 16 * beatTime;

    function scheduleLoop(startTime) {
        if (!bossMusic) return;

        for (let beat = 0; beat < 32; beat++) {
            const kickTime = startTime + beat * beatTime * 0.5;

            const kickOsc = audioCtx.createOscillator();
            const kickGain = audioCtx.createGain();
            kickOsc.type = 'sine';
            kickOsc.frequency.setValueAtTime(90, kickTime);
            kickOsc.frequency.exponentialRampToValueAtTime(28, kickTime + 0.1);
            kickGain.gain.setValueAtTime(0.4, kickTime);
            kickGain.gain.exponentialRampToValueAtTime(0.001, kickTime + 0.15);
            kickOsc.connect(kickGain);
            kickGain.connect(musicGain);
            kickOsc.start(kickTime);
            kickOsc.stop(kickTime + 0.2);
            musicNodes.push({osc: kickOsc});
        }

        for (let beat = 0; beat < 16; beat++) {
            if (beat % 2 === 1) {
                const snareTime = startTime + beat * beatTime;
                const snareBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
                const snareData = snareBuffer.getChannelData(0);
                for (let j = 0; j < snareBuffer.length; j++) {
                    const t = j / audioCtx.sampleRate;
                    const env = Math.pow(1 - j / snareBuffer.length, 1.5);
                    snareData[j] = (Math.sin(t * 200 * Math.PI * 2) * 0.5 + (Math.random() * 2 - 1) * 0.5) * env;
                }
                const snareSource = audioCtx.createBufferSource();
                const snareGain = audioCtx.createGain();
                snareSource.buffer = snareBuffer;
                snareGain.gain.value = 0.18;
                snareSource.connect(snareGain);
                snareGain.connect(musicGain);
                snareSource.start(snareTime);
                musicNodes.push({source: snareSource});
            }
        }

        for (let i = 0; i < 8; i++) {
            const bassTime = startTime + i * 2 * beatTime;
            const bassNote = bossNotes[i % 8];

            const bassOsc = audioCtx.createOscillator();
            const bassOsc2 = audioCtx.createOscillator();
            const distortion = audioCtx.createWaveShaper();
            const bassGain = audioCtx.createGain();

            bassOsc.type = 'sawtooth';
            bassOsc.frequency.value = bassNote;
            bassOsc2.type = 'square';
            bassOsc2.frequency.value = bassNote * 1.02;

            distortion.curve = makeDistortionCurve(30);

            bassGain.gain.setValueAtTime(0.12, bassTime);
            bassGain.gain.linearRampToValueAtTime(0.08, bassTime + beatTime * 1.8);

            bassOsc.connect(distortion);
            bassOsc2.connect(distortion);
            distortion.connect(bassGain);
            bassGain.connect(musicGain);
            bassOsc.start(bassTime);
            bassOsc2.start(bassTime);
            bassOsc.stop(bassTime + beatTime * 2);
            bassOsc2.stop(bassTime + beatTime * 2);
            musicNodes.push({osc: bassOsc});

            const subOsc = audioCtx.createOscillator();
            const subGain = audioCtx.createGain();
            subOsc.type = 'sine';
            subOsc.frequency.value = bassNote;
            subGain.gain.setValueAtTime(0.2, bassTime);
            subGain.gain.linearRampToValueAtTime(0.12, bassTime + beatTime * 1.8);
            subOsc.connect(subGain);
            subGain.connect(musicGain);
            subOsc.start(bassTime);
            subOsc.stop(bassTime + beatTime * 2);
            musicNodes.push({osc: subOsc});
        }

        const sirenOsc = audioCtx.createOscillator();
        const sirenGain = audioCtx.createGain();
        sirenOsc.type = 'sawtooth';

        for (let i = 0; i < 4; i++) {
            const t = startTime + i * 4 * beatTime;
            sirenOsc.frequency.setValueAtTime(200, t);
            sirenOsc.frequency.linearRampToValueAtTime(400, t + 2 * beatTime);
            sirenOsc.frequency.linearRampToValueAtTime(200, t + 4 * beatTime);
        }

        sirenGain.gain.value = 0.025;
        sirenOsc.connect(sirenGain);
        sirenGain.connect(musicGain);
        sirenOsc.start(startTime);
        sirenOsc.stop(startTime + loopDuration);
        musicNodes.push({osc: sirenOsc});

        setTimeout(() => scheduleLoop(startTime + loopDuration), (loopDuration - 0.5) * 1000);
    }

    scheduleLoop(now);
}

function stopBossMusic() {
    bossMusic = false;
    musicNodes.forEach(n => {
        try {
            if (n.osc) n.osc.stop();
            if (n.source) n.source.stop();
        } catch(e) {}
    });
    musicNodes = [];
}

// ============ CANVAS SETUP ============
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Colors
const MATRIX_GREEN = '#00ff41';
const MATRIX_DARK_GREEN = '#00b42d';
const MATRIX_CYAN = '#00ffc8';
const MATRIX_YELLOW = '#c8ff00';
const MATRIX_RED = '#ff3232';
const MATRIX_ORANGE = '#ff8c00';

// ============ CINEMATIC INTRO ============
const introLines = [
    "GPS signal lost.",
    "Visual navigation denied.",
    "When you can't see... you predict.",
    "VICTUS-1 // Contested Autonomy"
];

const loadingTips = [
    "When vision fails, prediction prevails.",
    "GPS is a luxury. Autonomy is a necessity.",
    "Tight CEP wins the fight.",
    "Trained in simulation. Proven in reality."
];

let introState = 'waiting'; // 'waiting', 'playing', 'done'
let introLineIndex = 0;
let introAlpha = 0;
let introTimer = 0;
let introPhase = 'fadeIn'; // 'fadeIn', 'hold', 'fadeOut'

// ============ GAME STATE ============
let gameState = 'intro'; // 'intro', 'title', 'playing', 'gameover', 'victory', 'levelComplete'
let score = 0;
let highScore = 0;
let level = 1;
let levelKills = 0;
let killsPerLevel = 10;
let bossFight = false;
let bossIntroTimer = 0;
let frameCount = 0;
let levelCompleteTimer = 0;
let navMode = 'STANDARD';
let navModeFlicker = 0;

// Boss definitions for each level
const BOSS_TYPES = {
    1: { name: 'THE JAMMER', health: 300, color: '#ff00ff', ability: 'emp' },
    2: { name: 'CLOUDBANK', health: 400, color: '#6666ff', ability: 'fog' },
    3: { name: 'THE SPOOFER', health: 500, color: '#ffff00', ability: 'decoy' },
    4: { name: 'DRIFT', health: 600, color: '#00ffff', ability: 'gravity' },
    5: { name: 'BLACKOUT', health: 800, color: '#ff0000', ability: 'all' }
};

// Player
const player = {
    x: 0, y: 0, width: 50, height: 40,
    speed: 12,
    health: 100, maxHealth: 100,
    bombs: 1, kills: 0, killsForBomb: 12,
    invincible: 0, shootTimer: 0, shootDelay: 6,
    driftX: 0, driftY: 0 // For gravity boss
};

// Arrays
let bullets = [];
let asteroids = [];
let particles = [];
let stars = [];
let bombs = [];
let boss = null;
let bossBullets = [];
let fireballs = [];
let decoys = []; // For spoofer boss
let fogZones = []; // For cloudbank boss
let gravityWells = []; // For drift boss
let empPulses = []; // For jammer boss

// Touch state
let touchX = null;
let touchY = null;
let touching = false;

// HUD scramble effect for jammer boss
let hudScramble = 0;

// ============ METEOR GRAPHICS ============
function drawMeteor(x, y, size, rotation, type) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);

    const points = [];
    const numPoints = 10;
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * Math.PI * 2;
        const variance = 0.6 + Math.random() * 0.4;
        const r = size * variance;
        points.push({
            x: Math.cos(angle) * r,
            y: Math.sin(angle) * r
        });
    }

    const gradient = ctx.createRadialGradient(size * 0.3, -size * 0.3, 0, 0, 0, size);
    if (type === 'speedy') {
        gradient.addColorStop(0, '#ffcc00');
        gradient.addColorStop(0.5, '#cc6600');
        gradient.addColorStop(1, '#663300');
    } else {
        gradient.addColorStop(0, '#888888');
        gradient.addColorStop(0.5, '#555555');
        gradient.addColorStop(1, '#222222');
    }

    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    for (let i = 0; i < 3; i++) {
        const cx = (Math.random() - 0.5) * size * 0.8;
        const cy = (Math.random() - 0.5) * size * 0.8;
        const cr = size * 0.15 + Math.random() * size * 0.1;
        ctx.beginPath();
        ctx.arc(cx, cy, cr, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.7, -Math.PI * 0.7, -Math.PI * 0.2);
    ctx.stroke();

    ctx.restore();
}

// ============ BOSS CLASS ============
function createBoss(levelNum) {
    const bossType = BOSS_TYPES[Math.min(levelNum, 5)];
    return {
        x: canvas.width / 2,
        y: -200,
        targetY: canvas.height * 0.15,
        size: 80 + levelNum * 10,
        health: bossType.health,
        maxHealth: bossType.health,
        name: bossType.name,
        color: bossType.color,
        ability: bossType.ability,
        phase: 1,
        rotation: 0,
        moveAngle: 0,
        shootTimer: 0,
        patternTimer: 0,
        abilityTimer: 0,
        defeated: false,
        defeatTimer: 0,
        targetX: canvas.width / 2,
        swooping: false,
        level: levelNum
    };
}

function updateBoss() {
    if (!boss) return;

    frameCount++;

    // Entry animation
    if (bossIntroTimer > 0) {
        bossIntroTimer--;
        boss.y += (boss.targetY - boss.y) * 0.03;
        if (bossIntroTimer % 30 === 0) playWarning();
        return;
    }

    if (boss.defeated) {
        boss.defeatTimer++;
        boss.rotation += 0.1;
        if (boss.defeatTimer % 8 === 0) {
            const ex = boss.x + (Math.random() - 0.5) * 200;
            const ey = boss.y + (Math.random() - 0.5) * 200;
            createExplosion(ex, ey, MATRIX_ORANGE, 25);
            playExplosion();
        }
        if (boss.defeatTimer >= 180) {
            // Level complete!
            if (level >= 5) {
                gameState = 'victory';
            } else {
                gameState = 'levelComplete';
                levelCompleteTimer = 180;
            }
            stopBossMusic();
            score += 2000 * level;
            if (score > highScore) highScore = score;
        }
        return;
    }

    // Phase transitions
    const healthPercent = boss.health / boss.maxHealth;
    if (healthPercent < 0.3) boss.phase = 3;
    else if (healthPercent < 0.6) boss.phase = 2;

    boss.rotation += 0.02 * boss.phase;
    boss.patternTimer++;
    boss.abilityTimer++;

    // Movement
    boss.moveAngle += 0.015 * boss.phase;
    boss.targetX = canvas.width / 2 + Math.sin(boss.moveAngle) * (canvas.width * 0.3);
    boss.y = boss.targetY + Math.sin(boss.moveAngle * 0.5) * 40;

    if (boss.patternTimer % (300 / boss.phase) === 0) {
        boss.swooping = true;
    }

    if (boss.swooping) {
        boss.y += 6;
        if (boss.y > canvas.height * 0.4) {
            boss.swooping = false;
        }
    } else if (boss.y > boss.targetY + 80) {
        boss.y -= 2;
    }

    boss.x += (boss.targetX - boss.x) * 0.05;

    // ============ BOSS ABILITIES ============

    // THE JAMMER - EMP pulses that scramble HUD
    if (boss.ability === 'emp' || boss.ability === 'all') {
        if (boss.abilityTimer % (180 / boss.phase) === 0) {
            empPulses.push({
                x: boss.x,
                y: boss.y,
                radius: 0,
                maxRadius: 400
            });
            navMode = 'DISRUPTED';
            hudScramble = 60;
        }
    }

    // CLOUDBANK - Fog zones
    if (boss.ability === 'fog' || boss.ability === 'all') {
        if (boss.abilityTimer % (200 / boss.phase) === 0) {
            fogZones.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.6,
                radius: 100 + Math.random() * 100,
                life: 300
            });
        }
    }

    // THE SPOOFER - Decoy copies
    if (boss.ability === 'decoy' || boss.ability === 'all') {
        if (boss.abilityTimer % (240 / boss.phase) === 0 && decoys.length < 3) {
            decoys.push({
                x: boss.x + (Math.random() - 0.5) * 200,
                y: boss.y + (Math.random() - 0.5) * 100,
                size: boss.size * 0.8,
                rotation: boss.rotation,
                life: 180,
                moveAngle: Math.random() * Math.PI * 2
            });
            navMode = 'PREDICTIVE';
        }
    }

    // DRIFT - Gravity wells
    if (boss.ability === 'gravity' || boss.ability === 'all') {
        if (boss.abilityTimer % (150 / boss.phase) === 0 && gravityWells.length < 4) {
            gravityWells.push({
                x: Math.random() * canvas.width,
                y: canvas.height * 0.3 + Math.random() * canvas.height * 0.4,
                strength: 0.3 + Math.random() * 0.3,
                life: 240
            });
        }
    }

    // Update EMP pulses
    empPulses = empPulses.filter(emp => {
        emp.radius += 8;
        return emp.radius < emp.maxRadius;
    });

    // Update fog zones
    fogZones = fogZones.filter(fog => {
        fog.life--;
        return fog.life > 0;
    });

    // Update decoys
    decoys = decoys.filter(decoy => {
        decoy.life--;
        decoy.moveAngle += 0.05;
        decoy.x += Math.sin(decoy.moveAngle) * 2;
        decoy.rotation += 0.02;
        return decoy.life > 0;
    });

    // Update gravity wells
    gravityWells = gravityWells.filter(well => {
        well.life--;
        // Apply gravity to player
        const dx = well.x - (player.x + player.width/2);
        const dy = well.y - (player.y + player.height/2);
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 200 && dist > 10) {
            player.driftX += (dx / dist) * well.strength;
            player.driftY += (dy / dist) * well.strength;
        }
        return well.life > 0;
    });

    // Reset nav mode if not disrupted
    if (hudScramble <= 0 && decoys.length === 0) {
        navMode = 'STANDARD';
    }

    // ============ ATTACK PATTERNS ============
    boss.shootTimer++;

    // Pattern 1: Aimed fireballs
    if (boss.shootTimer % Math.max(25, 50 - boss.phase * 10) === 0) {
        const angle = Math.atan2(
            player.y + player.height/2 - boss.y,
            player.x + player.width/2 - boss.x
        );
        createFireball(boss.x, boss.y + boss.size * 0.5, angle, 5 + boss.phase);
        playBossShoot();
    }

    // Pattern 2: Spread shot
    if (boss.shootTimer % Math.max(50, 100 - boss.phase * 20) === 0) {
        const baseAngle = Math.PI / 2;
        const spread = 3 + boss.phase;
        for (let i = 0; i < spread; i++) {
            const angle = baseAngle + (i - (spread-1)/2) * 0.25;
            createFireball(boss.x, boss.y + boss.size * 0.5, angle, 4);
        }
        playBossShoot();
    }

    // Update fireballs
    fireballs = fireballs.filter(f => {
        f.x += f.vx;
        f.y += f.vy;

        if (player.invincible <= 0) {
            const dx = f.x - (player.x + player.width/2);
            const dy = f.y - (player.y + player.height/2);
            if (Math.sqrt(dx*dx + dy*dy) < f.size + 20) {
                player.health -= 12;
                player.invincible = 30;
                createExplosion(f.x, f.y, MATRIX_RED, 10);
                return false;
            }
        }

        return f.y < canvas.height + 50 && f.x > -50 && f.x < canvas.width + 50;
    });

    // Player bullets hit boss
    bullets.forEach((bullet, bi) => {
        const dx = bullet.x - boss.x;
        const dy = bullet.y - boss.y;
        if (Math.sqrt(dx*dx + dy*dy) < boss.size) {
            bullets.splice(bi, 1);
            boss.health -= 2;
            createExplosion(bullet.x, bullet.y, MATRIX_CYAN, 5);
            playBossHit();
            if (boss.health <= 0) {
                boss.defeated = true;
            }
        }
    });

    // Bombs damage boss
    bombs.forEach(bomb => {
        const dx = boss.x - bomb.x;
        const dy = boss.y - bomb.y;
        if (Math.sqrt(dx*dx + dy*dy) < bomb.radius + boss.size) {
            boss.health -= 8;
            if (boss.health <= 0) boss.defeated = true;
        }
        fireballs = fireballs.filter(f => {
            const fdx = f.x - bomb.x;
            const fdy = f.y - bomb.y;
            return Math.sqrt(fdx*fdx + fdy*fdy) > bomb.radius;
        });
    });

    if (player.health <= 0) {
        gameState = 'gameover';
        stopBossMusic();
        if (score > highScore) highScore = score;
    }
}

function createFireball(x, y, angle, speed) {
    fireballs.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 10,
        type: 'fireball'
    });
}

function drawBoss() {
    if (!boss) return;

    // Draw decoys first (slightly transparent)
    decoys.forEach(decoy => {
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.translate(decoy.x, decoy.y);
        ctx.rotate(decoy.rotation);

        ctx.strokeStyle = boss.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, decoy.size, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    });

    // Draw fog zones
    fogZones.forEach(fog => {
        const alpha = Math.min(0.7, fog.life / 100);
        const gradient = ctx.createRadialGradient(fog.x, fog.y, 0, fog.x, fog.y, fog.radius);
        gradient.addColorStop(0, `rgba(100, 100, 150, ${alpha})`);
        gradient.addColorStop(1, 'rgba(100, 100, 150, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(fog.x, fog.y, fog.radius, 0, Math.PI * 2);
        ctx.fill();
    });

    // Draw gravity wells
    gravityWells.forEach(well => {
        const alpha = well.life / 240;
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.lineWidth = 2;
        for (let r = 20; r < 80; r += 20) {
            ctx.beginPath();
            ctx.arc(well.x, well.y, r, 0, Math.PI * 2);
            ctx.stroke();
        }
    });

    // Draw EMP pulses
    empPulses.forEach(emp => {
        const alpha = 1 - emp.radius / emp.maxRadius;
        ctx.strokeStyle = `rgba(255, 0, 255, ${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(emp.x, emp.y, emp.radius, 0, Math.PI * 2);
        ctx.stroke();
    });

    ctx.save();
    ctx.translate(boss.x, boss.y);

    // Outer rotating ring
    ctx.save();
    ctx.rotate(boss.rotation);

    const healthPercent = boss.health / boss.maxHealth;
    const ringColor = boss.defeated ? MATRIX_RED : boss.color;

    ctx.strokeStyle = ringColor;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(0, 0, boss.size + 20, 0, Math.PI * 2);
    ctx.stroke();

    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * boss.size * 0.5, Math.sin(angle) * boss.size * 0.5);
        ctx.lineTo(Math.cos(angle) * (boss.size + 20), Math.sin(angle) * (boss.size + 20));
        ctx.stroke();
    }
    ctx.restore();

    // Inner rotating ring
    ctx.save();
    ctx.rotate(-boss.rotation * 1.5);
    ctx.strokeStyle = MATRIX_GREEN;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, boss.size * 0.7, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // Core
    const pulse = 1 + Math.sin(frameCount * 0.1) * 0.1;
    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, boss.size * 0.4 * pulse);
    coreGradient.addColorStop(0, '#ffffff');
    coreGradient.addColorStop(0.3, ringColor);
    coreGradient.addColorStop(1, 'rgba(0,0,0,0)');

    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(0, 0, boss.size * 0.4 * pulse, 0, Math.PI * 2);
    ctx.fill();

    // Eye
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(0, 0, boss.size * 0.15, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = MATRIX_RED;
    ctx.beginPath();
    ctx.arc(0, 0, boss.size * 0.08, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Boss name and health bar
    const barWidth = 200;
    const barX = canvas.width/2 - barWidth/2;

    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(barX - 2, 48, barWidth + 4, 24);

    ctx.strokeStyle = boss.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, 50, barWidth, 20);

    ctx.fillStyle = healthPercent < 0.3 ? '#ff0000' : healthPercent < 0.6 ? MATRIX_ORANGE : boss.color;
    ctx.fillRect(barX + 2, 52, (barWidth - 4) * healthPercent, 16);

    ctx.fillStyle = boss.color;
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(boss.name, canvas.width/2, 88);

    // Draw fireballs
    fireballs.forEach(f => {
        ctx.save();
        ctx.translate(f.x, f.y);

        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, f.size);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.3, '#ffff00');
        gradient.addColorStop(0.6, '#ff6600');
        gradient.addColorStop(1, 'rgba(255,0,0,0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, f.size, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    });
}

// ============ PARTICLES & EFFECTS ============
function createExplosion(x, y, color, count = 15) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 6;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 25 + Math.random() * 20,
            maxLife: 45,
            color,
            size: 2 + Math.random() * 4
        });
    }
}

// ============ INIT ============
function initStars() {
    stars = [];
    for (let i = 0; i < 150; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            speed: 2 + Math.random() * 5,
            size: Math.random() * 2.5
        });
    }
}

function resetGame() {
    player.x = canvas.width / 2 - player.width / 2;
    player.y = canvas.height - 120;
    player.health = 100;
    player.bombs = 1;
    player.kills = 0;
    player.invincible = 0;
    player.driftX = 0;
    player.driftY = 0;
    score = 0;
    level = 1;
    levelKills = 0;
    bossFight = false;
    boss = null;
    bullets = [];
    asteroids = [];
    particles = [];
    bombs = [];
    fireballs = [];
    decoys = [];
    fogZones = [];
    gravityWells = [];
    empPulses = [];
    hudScramble = 0;
    navMode = 'STANDARD';
    initStars();
    gameState = 'playing';
    stopBossMusic();
    startMusic();
}

function startNextLevel() {
    level++;
    levelKills = 0;
    bossFight = false;
    boss = null;
    fireballs = [];
    decoys = [];
    fogZones = [];
    gravityWells = [];
    empPulses = [];
    hudScramble = 0;
    navMode = 'STANDARD';
    player.health = Math.min(100, player.health + 30); // Heal a bit
    player.bombs++;
    gameState = 'playing';
    stopBossMusic();
    startMusic();
}

// ============ DIFFICULTY SCALING ============
function getLevelDifficulty() {
    // Returns difficulty multipliers based on level
    return {
        asteroidSpeed: 1 + (level - 1) * 0.15,      // 15% faster per level
        spawnRate: 0.02 + (level - 1) * 0.008,      // More frequent spawns
        asteroidTypes: Math.min(level, 5),           // More types available
        killsRequired: killsPerLevel + (level - 1) * 3 // More kills per level
    };
}

// ============ SPAWN ASTEROID ============
function spawnAsteroid() {
    const diff = getLevelDifficulty();

    const types = ['small'];
    if (diff.asteroidTypes >= 2) types.push('medium');
    if (diff.asteroidTypes >= 3) types.push('speedy');
    if (diff.asteroidTypes >= 4) types.push('large');
    if (diff.asteroidTypes >= 5) types.push('huge');

    const type = types[Math.floor(Math.random() * types.length)];
    let size, speed, health, points;

    switch(type) {
        case 'small': size = 22; speed = (3 + Math.random() * 2) * diff.asteroidSpeed; health = 1; points = 10; break;
        case 'medium': size = 38; speed = (2 + Math.random() * 1.5) * diff.asteroidSpeed; health = 2; points = 25; break;
        case 'speedy': size = 18; speed = (6 + Math.random() * 3) * diff.asteroidSpeed; health = 1; points = 30; break;
        case 'large': size = 55; speed = (1.5 + Math.random() * 1) * diff.asteroidSpeed; health = 4; points = 60; break;
        case 'huge': size = 75; speed = (1 + Math.random() * 0.5) * diff.asteroidSpeed; health = 6; points = 100; break;
    }

    asteroids.push({
        x: Math.random() * (canvas.width - size * 2) + size,
        y: -size,
        size, speed, health, points, type,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.08,
        seed: Math.random() * 1000
    });
}

// ============ UPDATE ============
function update() {
    frameCount++;

    // Always update stars
    stars.forEach(star => {
        star.y += star.speed;
        if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
        }
    });

    // Handle intro
    if (gameState === 'intro') {
        updateIntro();
        return;
    }

    if (gameState === 'levelComplete') {
        levelCompleteTimer--;
        if (levelCompleteTimer <= 0) {
            startNextLevel();
        }
        return;
    }

    if (gameState !== 'playing') return;

    // Decay HUD scramble
    if (hudScramble > 0) hudScramble--;

    // Apply and decay drift
    player.x += player.driftX;
    player.y += player.driftY;
    player.driftX *= 0.95;
    player.driftY *= 0.95;

    // Player movement
    if (touching && touchX !== null) {
        const dx = touchX - player.x - player.width/2;
        const dy = touchY - player.y - player.height/2;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 5) {
            const moveSpeed = Math.min(player.speed, dist * 0.3);
            player.x += (dx / dist) * moveSpeed;
            player.y += (dy / dist) * moveSpeed;
        }
    }

    player.x = Math.max(10, Math.min(canvas.width - player.width - 10, player.x));
    player.y = Math.max(50, Math.min(canvas.height - player.height - 80, player.y));

    // Auto-shoot
    player.shootTimer--;
    if (player.shootTimer <= 0) {
        bullets.push({
            x: player.x + player.width/2 - 3,
            y: player.y,
            width: 6, height: 18, speed: 15
        });
        player.shootTimer = player.shootDelay;
    }

    // Update bullets
    bullets = bullets.filter(b => {
        b.y -= b.speed;
        return b.y > -20;
    });

    if (player.invincible > 0) player.invincible--;

    // Boss fight
    if (bossFight) {
        updateBoss();
        return;
    }

    // Spawn asteroids
    const diff = getLevelDifficulty();
    if (Math.random() < diff.spawnRate) {
        spawnAsteroid();
    }

    // Update asteroids
    asteroids = asteroids.filter(a => {
        a.y += a.speed;
        a.rotation += a.rotSpeed;
        return a.y < canvas.height + 80;
    });

    // Bullet-asteroid collisions
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const bullet = bullets[bi];
        for (let ai = asteroids.length - 1; ai >= 0; ai--) {
            const asteroid = asteroids[ai];
            const dx = bullet.x - asteroid.x;
            const dy = bullet.y - asteroid.y;
            if (Math.sqrt(dx*dx + dy*dy) < asteroid.size) {
                bullets.splice(bi, 1);
                asteroid.health--;

                if (asteroid.health <= 0) {
                    createExplosion(asteroid.x, asteroid.y, MATRIX_GREEN, 18);
                    playExplosion();
                    score += asteroid.points;
                    levelKills++;
                    player.kills++;
                    if (player.kills >= player.killsForBomb) {
                        player.kills = 0;
                        player.bombs++;
                    }
                    asteroids.splice(ai, 1);
                } else {
                    createExplosion(asteroid.x, asteroid.y, MATRIX_YELLOW, 5);
                }
                break;
            }
        }
    }

    // Player-asteroid collisions
    if (player.invincible <= 0) {
        for (let ai = asteroids.length - 1; ai >= 0; ai--) {
            const asteroid = asteroids[ai];
            const dx = (player.x + player.width/2) - asteroid.x;
            const dy = (player.y + player.height/2) - asteroid.y;
            if (Math.sqrt(dx*dx + dy*dy) < asteroid.size + 15) {
                player.health -= 20;
                player.invincible = 60;
                createExplosion(asteroid.x, asteroid.y, MATRIX_RED, 20);
                playExplosion();
                asteroids.splice(ai, 1);
            }
        }
    }

    // Update bombs
    bombs = bombs.filter(bomb => {
        bomb.radius += 18;
        bomb.alpha -= 0.015;

        asteroids = asteroids.filter(a => {
            const dx = a.x - bomb.x;
            const dy = a.y - bomb.y;
            if (Math.sqrt(dx*dx + dy*dy) < bomb.radius) {
                createExplosion(a.x, a.y, MATRIX_ORANGE, 15);
                score += a.points;
                return false;
            }
            return true;
        });

        return bomb.alpha > 0;
    });

    // Update particles
    particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.life--;
        return p.life > 0;
    });

    // Level progression - boss at end of each level
    if (levelKills >= diff.killsRequired) {
        bossFight = true;
        boss = createBoss(level);
        bossIntroTimer = 150;
        stopMusic();
        setTimeout(() => startBossMusic(), 1000);
    }

    if (player.health <= 0) {
        gameState = 'gameover';
        stopMusic();
        if (score > highScore) highScore = score;
    }
}

function updateIntro() {
    introTimer++;

    if (introPhase === 'fadeIn') {
        introAlpha += 0.02;
        if (introAlpha >= 1) {
            introAlpha = 1;
            introPhase = 'hold';
            introTimer = 0;
        }
    } else if (introPhase === 'hold') {
        if (introTimer >= 90) { // ~1.5 seconds
            introPhase = 'fadeOut';
            introTimer = 0;
        }
    } else if (introPhase === 'fadeOut') {
        introAlpha -= 0.02;
        if (introAlpha <= 0) {
            introAlpha = 0;
            introLineIndex++;
            if (introLineIndex >= introLines.length) {
                gameState = 'title';
            } else {
                introPhase = 'fadeIn';
            }
        }
    }
}

// ============ DRAW ============
function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Stars (always visible)
    stars.forEach(star => {
        const alpha = 0.3 + star.speed / 8;
        ctx.fillStyle = `rgba(0, 255, 65, ${alpha})`;
        ctx.fillRect(star.x, star.y, star.size, star.size * 2);
    });

    if (gameState === 'intro') {
        drawIntro();
        return;
    }

    if (gameState === 'title') {
        drawTitle();
        return;
    }

    if (gameState === 'levelComplete') {
        drawLevelComplete();
        return;
    }

    // Particles
    particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Bombs
    bombs.forEach(bomb => {
        ctx.strokeStyle = MATRIX_CYAN;
        ctx.globalAlpha = bomb.alpha;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(bomb.x, bomb.y, bomb.radius, 0, Math.PI * 2);
        ctx.stroke();

        ctx.strokeStyle = MATRIX_GREEN;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(bomb.x, bomb.y, bomb.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
    });
    ctx.globalAlpha = 1;

    // Asteroids
    asteroids.forEach(a => {
        drawMeteor(a.x, a.y, a.size, a.rotation, a.type);
    });

    // Bullets
    bullets.forEach(b => {
        const gradient = ctx.createLinearGradient(b.x, b.y + b.height, b.x, b.y);
        gradient.addColorStop(0, 'rgba(0,255,200,0)');
        gradient.addColorStop(0.5, MATRIX_CYAN);
        gradient.addColorStop(1, '#ffffff');
        ctx.fillStyle = gradient;
        ctx.fillRect(b.x, b.y, b.width, b.height);
    });

    // Boss
    if (boss) {
        drawBoss();
    }

    // Player
    if (player.invincible === 0 || Math.floor(player.invincible / 3) % 2 === 0) {
        ctx.fillStyle = MATRIX_GREEN;
        ctx.beginPath();
        ctx.moveTo(player.x + player.width/2, player.y);
        ctx.lineTo(player.x + 5, player.y + player.height);
        ctx.lineTo(player.x + player.width - 5, player.y + player.height);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = MATRIX_DARK_GREEN;
        ctx.beginPath();
        ctx.moveTo(player.x, player.y + player.height * 0.6);
        ctx.lineTo(player.x + 15, player.y + player.height);
        ctx.lineTo(player.x + 5, player.y + player.height);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(player.x + player.width, player.y + player.height * 0.6);
        ctx.lineTo(player.x + player.width - 15, player.y + player.height);
        ctx.lineTo(player.x + player.width - 5, player.y + player.height);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = MATRIX_CYAN;
        ctx.beginPath();
        ctx.ellipse(player.x + player.width/2, player.y + player.height * 0.4, 6, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        const flameHeight = 15 + Math.random() * 12;
        const gradient = ctx.createLinearGradient(
            player.x + player.width/2, player.y + player.height,
            player.x + player.width/2, player.y + player.height + flameHeight
        );
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.3, MATRIX_CYAN);
        gradient.addColorStop(1, 'rgba(0,255,200,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(player.x + player.width/2 - 10, player.y + player.height);
        ctx.lineTo(player.x + player.width/2, player.y + player.height + flameHeight);
        ctx.lineTo(player.x + player.width/2 + 10, player.y + player.height);
        ctx.closePath();
        ctx.fill();
    }

    // HUD
    drawHUD();

    // Boss intro
    if (bossIntroTimer > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (Math.floor(bossIntroTimer / 12) % 2 === 0) {
            ctx.fillStyle = MATRIX_RED;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('WARNING!', canvas.width/2, canvas.height/2 - 30);

            ctx.font = '24px Arial';
            ctx.fillStyle = boss.color;
            ctx.fillText(boss.name + ' APPROACHING', canvas.width/2, canvas.height/2 + 20);
        }
    }

    if (gameState === 'gameover') drawGameOver();
    if (gameState === 'victory') drawVictory();
}

function drawIntro() {
    ctx.fillStyle = `rgba(0, 255, 65, ${introAlpha})`;
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(introLines[introLineIndex], canvas.width/2, canvas.height/2);
}

function drawTitle() {
    ctx.fillStyle = MATRIX_GREEN;
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('VICTUS-1', canvas.width/2, canvas.height/3);

    ctx.fillStyle = MATRIX_CYAN;
    ctx.font = '20px Arial';
    ctx.fillText('CONTESTED AUTONOMY', canvas.width/2, canvas.height/3 + 35);

    ctx.fillStyle = '#fff';
    ctx.font = '18px Arial';
    ctx.fillText('DRAG to move', canvas.width/2, canvas.height/2);
    ctx.fillStyle = MATRIX_YELLOW;
    ctx.fillText('Tap BOMB to clear screen', canvas.width/2, canvas.height/2 + 30);

    // Loading tip
    ctx.fillStyle = MATRIX_DARK_GREEN;
    ctx.font = '14px Arial';
    const tip = loadingTips[Math.floor(frameCount / 180) % loadingTips.length];
    ctx.fillText(tip, canvas.width/2, canvas.height * 0.65);

    ctx.fillStyle = MATRIX_GREEN;
    ctx.font = '24px Arial';
    const pulse = 1 + Math.sin(frameCount * 0.1) * 0.1;
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height * 0.78);
    ctx.scale(pulse, pulse);
    ctx.fillText('TAP TO START', 0, 0);
    ctx.restore();

    if (highScore > 0) {
        ctx.fillStyle = MATRIX_CYAN;
        ctx.font = '18px Arial';
        ctx.fillText(`High Score: ${highScore}`, canvas.width/2, canvas.height * 0.88);
    }
}

function drawLevelComplete() {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = MATRIX_GREEN;
    ctx.font = 'bold 42px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level} COMPLETE`, canvas.width/2, canvas.height/2 - 40);

    ctx.fillStyle = MATRIX_CYAN;
    ctx.font = '24px Arial';
    ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 10);

    ctx.fillStyle = MATRIX_YELLOW;
    ctx.font = '18px Arial';
    ctx.fillText('Preparing next level...', canvas.width/2, canvas.height/2 + 60);
}

function drawHUD() {
    // Apply scramble effect
    const scrambleOffset = hudScramble > 0 ? (Math.random() - 0.5) * 10 : 0;

    // VICTUS-1 title - always visible at top center
    ctx.textAlign = 'center';
    ctx.font = 'bold 28px Arial';
    const titleGlow = Math.sin(frameCount * 0.05) * 0.3 + 0.7;
    ctx.fillStyle = `rgba(0, 255, 65, ${titleGlow})`;
    ctx.fillText('VICTUS-1', canvas.width/2 + scrambleOffset, 28);

    // NAV MODE indicator
    ctx.font = '12px Arial';
    if (navMode === 'STANDARD') {
        ctx.fillStyle = MATRIX_DARK_GREEN;
    } else if (navMode === 'PREDICTIVE') {
        ctx.fillStyle = MATRIX_YELLOW;
    } else {
        ctx.fillStyle = MATRIX_RED;
    }

    // Flicker effect for non-standard modes
    if (navMode !== 'STANDARD' && Math.random() > 0.9) {
        ctx.fillStyle = 'rgba(0,0,0,0)';
    }
    ctx.fillText(`NAV: ${navMode}`, canvas.width/2, 44);

    // Score - left side
    ctx.fillStyle = MATRIX_CYAN;
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'left';
    const scoreText = hudScramble > 0 ?
        'SCORE: ' + String(score).split('').map(() => Math.floor(Math.random()*10)).join('') :
        `SCORE: ${score}`;
    ctx.fillText(scoreText, 10, 28);

    // Level - below title
    if (!bossFight) {
        ctx.textAlign = 'center';
        ctx.fillStyle = MATRIX_DARK_GREEN;
        ctx.font = '14px Arial';
        ctx.fillText(`LEVEL ${level}/5`, canvas.width/2, 60);
    }

    // ============ BOMB BUTTON - BOTTOM OF SCREEN ============
    const btnW = 80;
    const btnH = 60;
    const btnX = canvas.width/2 - btnW/2;
    const btnY = canvas.height - btnH - 10;

    ctx.fillStyle = 'rgba(0, 60, 0, 0.9)';
    ctx.fillRect(btnX, btnY, btnW, btnH);
    ctx.strokeStyle = player.bombs > 0 ? MATRIX_GREEN : MATRIX_DARK_GREEN;
    ctx.lineWidth = 2;
    ctx.strokeRect(btnX, btnY, btnW, btnH);

    ctx.fillStyle = player.bombs > 0 ? MATRIX_YELLOW : MATRIX_DARK_GREEN;
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(player.bombs.toString(), btnX + btnW/2, btnY + 35);
    ctx.fillStyle = MATRIX_DARK_GREEN;
    ctx.font = '12px Arial';
    ctx.fillText('BOMB', btnX + btnW/2, btnY + 52);

    // Health bar - above bomb button
    const healthW = canvas.width - 20;
    const healthH = 16;
    const healthX = 10;
    const healthY = canvas.height - btnH - 40;

    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(healthX - 2, healthY - 2, healthW + 4, healthH + 4);
    ctx.strokeStyle = MATRIX_DARK_GREEN;
    ctx.lineWidth = 2;
    ctx.strokeRect(healthX, healthY, healthW, healthH);

    const healthFill = (player.health / player.maxHealth) * (healthW - 4);
    if (healthFill > 0) {
        const healthGradient = ctx.createLinearGradient(healthX, 0, healthX + healthW, 0);
        if (player.health > 30) {
            healthGradient.addColorStop(0, MATRIX_DARK_GREEN);
            healthGradient.addColorStop(1, MATRIX_GREEN);
        } else {
            healthGradient.addColorStop(0, '#aa0000');
            healthGradient.addColorStop(1, MATRIX_RED);
        }
        ctx.fillStyle = healthGradient;
        ctx.fillRect(healthX + 2, healthY + 2, healthFill, healthH - 4);
    }

    // Level progress
    if (!bossFight) {
        const diff = getLevelDifficulty();
        ctx.fillStyle = MATRIX_DARK_GREEN;
        ctx.font = '14px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(`${levelKills}/${diff.killsRequired}`, canvas.width - 12, healthY - 8);
    }
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = MATRIX_RED;
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('MISSION FAILED', canvas.width/2, canvas.height/2 - 60);

    ctx.fillStyle = MATRIX_CYAN;
    ctx.font = '24px Arial';
    ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2);
    ctx.fillText(`High Score: ${highScore}`, canvas.width/2, canvas.height/2 + 40);

    ctx.fillStyle = MATRIX_DARK_GREEN;
    ctx.font = '14px Arial';
    ctx.fillText('VICTUS-1 Autonomous Platform Lost', canvas.width/2, canvas.height/2 + 90);

    ctx.fillStyle = '#fff';
    ctx.font = '22px Arial';
    ctx.fillText('TAP TO RESTART', canvas.width/2, canvas.height/2 + 140);
}

function drawVictory() {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = MATRIX_GREEN;
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('MISSION COMPLETE', canvas.width/2, canvas.height/2 - 80);

    ctx.fillStyle = MATRIX_YELLOW;
    ctx.font = '20px Arial';
    ctx.fillText('CONTESTED NAVIGATOR', canvas.width/2, canvas.height/2 - 40);

    ctx.fillStyle = MATRIX_CYAN;
    ctx.font = '24px Arial';
    ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 10);
    ctx.fillText(`High Score: ${highScore}`, canvas.width/2, canvas.height/2 + 50);

    ctx.fillStyle = MATRIX_DARK_GREEN;
    ctx.font = '14px Arial';
    ctx.fillText('VICTUS-1 // Autonomy Proven', canvas.width/2, canvas.height/2 + 100);

    ctx.fillStyle = '#fff';
    ctx.font = '22px Arial';
    ctx.fillText('TAP TO PLAY AGAIN', canvas.width/2, canvas.height/2 + 150);
}

// ============ INPUT ============
function handleStart(x, y) {
    initAudio();

    if (gameState === 'intro') {
        // Skip intro
        gameState = 'title';
        return;
    }

    if (gameState === 'title') {
        resetGame();
        return;
    }

    if (gameState === 'gameover' || gameState === 'victory') {
        gameState = 'title';
        return;
    }

    // Bomb button - NOW AT BOTTOM CENTER
    const btnW = 80;
    const btnH = 60;
    const btnX = canvas.width/2 - btnW/2;
    const btnY = canvas.height - btnH - 10;

    if (x > btnX && x < btnX + btnW && y > btnY && y < btnY + btnH) {
        if (player.bombs > 0) {
            player.bombs--;
            bombs.push({
                x: player.x + player.width/2,
                y: player.y + player.height/2,
                radius: 20,
                alpha: 1
            });
            playBomb();
        }
        return;
    }

    touching = true;
    touchX = x;
    touchY = y;
}

function handleMove(x, y) {
    if (touching) {
        touchX = x;
        touchY = y;
    }
}

function handleEnd() {
    touching = false;
}

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    handleStart(
        (touch.clientX - rect.left) * (canvas.width / rect.width),
        (touch.clientY - rect.top) * (canvas.height / rect.height)
    );
});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    handleMove(
        (touch.clientX - rect.left) * (canvas.width / rect.width),
        (touch.clientY - rect.top) * (canvas.height / rect.height)
    );
});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    handleEnd();
});

canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    handleStart(
        (e.clientX - rect.left) * (canvas.width / rect.width),
        (e.clientY - rect.top) * (canvas.height / rect.height)
    );
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    handleMove(
        (e.clientX - rect.left) * (canvas.width / rect.width),
        (e.clientY - rect.top) * (canvas.height / rect.height)
    );
});

canvas.addEventListener('mouseup', handleEnd);

// ============ GAME LOOP ============
initStars();
player.x = canvas.width / 2 - player.width / 2;
player.y = canvas.height - 120;

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
